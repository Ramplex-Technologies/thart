{"version":3,"sources":["../src/primary.ts","../src/types.ts"],"sourcesContent":["import { type ChildProcess, fork } from \"node:child_process\";\nimport cluster, { type Worker } from \"node:cluster\";\nimport type { ShutdownManager } from \"./async-shutdown\";\nimport {\n  WORKER_TYPES,\n  type NormalizedThartOptions,\n  type WorkerFunction,\n} from \"./types\";\n\nexport async function startPrimary(\n  options: NormalizedThartOptions,\n  manager: ShutdownManager,\n): Promise<void> {\n  if (!cluster.isPrimary) {\n    throw new Error(\"Can not invoke `startPrimary` outside of `primary`\");\n  }\n  if (options.primary) await options.primary.start();\n  const childProcesses: ChildProcess[] = [];\n  manager.addListener(async () => {\n    try {\n      await waitForWorkersWithTimeout(options.grace, childProcesses);\n    } finally {\n      if (options.primary?.stop) await options.primary.stop();\n      process.exitCode = 0;\n    }\n  });\n  for (let i = 0; i < options.worker.length; i++) {\n    spawnWorker(i, options.worker[i], childProcesses);\n  }\n}\n\nexport function spawnWorker(\n  i: number,\n  workerConfig: WorkerFunction,\n  childProcesses: ChildProcess[],\n): void {\n  if (workerConfig.type === WORKER_TYPES.child) {\n    const childProcess = fork(process.argv[1], [], {\n      env: {\n        ...process.env,\n        WORKER_ID: i.toString(),\n        WORKER_TYPE: WORKER_TYPES.child,\n      },\n    });\n    childProcesses.push(childProcess);\n  } else if (workerConfig.type === WORKER_TYPES.cluster) {\n    cluster.fork({\n      WORKER_ID: i.toString(),\n      WORKER_TYPE: WORKER_TYPES.cluster,\n    });\n  } else throw new Error(`Invalid worker type: ${workerConfig.type}`);\n}\n\n/**\n * Waits for all workers and child processes to terminate within a specified grace period.\n *\n * This function periodically checks the status of cluster workers and child processes.\n * It resolves when all workers and child processes have terminated.\n * If the grace period expires before all workers and child processes have terminated,\n * it forcibly terminates them and rejects with an error.\n *\n * @param {number} grace - The maximum time (in milliseconds) to wait for workers and child processes to terminate.\n * @param {ChildProcess[]} childProcesses - An array of child processes to monitor.\n * @returns {Promise<void>} A promise that resolves when all workers and child processes have terminated,\n *                          or rejects if the grace period expires.\n * @throws {Error} If the grace period expires before all workers and child processes terminate.\n */\nexport function waitForWorkersWithTimeout(\n  grace: number,\n  childProcesses: ChildProcess[],\n): Promise<void> {\n  return new Promise<void>((resolve, reject) => {\n    const startTime = Date.now();\n    const intervalId = setInterval(() => {\n      const workers = getConnectedWorkers();\n      // really this triggers when the cluster workers array is empty but we keep the isDead\n      // check for the case where cluster.workers returns a dictionary containing dead workers\n      // (though I have never observed this to be the case)\n      const allWorkersDead = workers.every((w) => !!w && w.isDead());\n      const allChildProcessesDead = childProcesses.every(\n        // need the `exitCode` check to ensure we count processes that exited due to:\n        // 1) empty event loop\n        // 2) process.exit invocations\n        (child) => child.signalCode !== null || child.exitCode !== null,\n      );\n\n      if (allWorkersDead && allChildProcessesDead) {\n        clearInterval(intervalId);\n        resolve();\n      }\n\n      if (Date.now() - startTime >= grace) {\n        console.error(\"Forcibly terminating workers after grace period\");\n        clearInterval(intervalId);\n        workers.forEach((worker) => worker?.kill());\n        childProcesses.forEach((cp) => cp.kill());\n        reject(new Error(\"Forcibly terminated workers after grace period\"));\n      }\n    }, 100);\n  });\n}\n\n/**\n * @returns An array of active workers in the cluster if invoked in the primary process, else an empty array.\n */\nfunction getConnectedWorkers(): (Worker | undefined)[] {\n  return Object.values(cluster.workers ?? {});\n}\n","interface CommonThartOptions {\n  /**\n   * The grace period for shutting down worker processes in milliseconds.\n   * This determines how long to wait for workers to finish their tasks before forcefully terminating them.\n   *\n   * @default 10000 (10 seconds)\n   */\n  grace?: number;\n}\n\ntype PrimaryFunction = {\n  /**\n   * A function to be executed in the primary process (there is only one primary process).\n   */\n  start: () => Promise<void> | void;\n  /**\n   * A function to be executed in the primary process when the primary process is shutting down.\n   * This gets invoked AFTER all worker processes have been shut down.\n   */\n  stop?: () => Promise<void> | void;\n};\n\ntype WorkerCount = {\n  /**\n   * A function to be executed in each worker process when the worker process is shutting down.\n   * @param id - The id of the worker process.\n   * @returns A promise that resolves when the worker process has completed.\n   */\n  /**\n   * The number of worker processes to spawn.\n   */\n  count: number;\n};\n\ntype WorkerFunction = {\n  /**\n   * A function to be executed in each worker process (there is no limit to the number of worker processes).\n   * @param id - The id of the worker process.\n   * @returns A promise that resolves when the worker process has completed.\n   */\n  start: (id: number) => Promise<void> | void;\n  /**\n   * The type of worker process to use.\n   * \"childProcess\" will use Node.js child processes.\n   * \"cluster\" will use Node.js cluster module.\n   *\n   * You should use:\n   * - \"cluster\" allows TCP servers to be shared between workers and is thus recommended when using TCP servers.\n   * - \"childProcess\" is recommended for CPU-bound tasks / jobs that can be run independently.\n   */\n  type: \"childProcess\" | \"cluster\";\n  /**\n   * Determines whether the worker process should be terminated after completing its task.\n   * By default, when all work in the process is done, the node process that executed the worker is still kept alive.\n   * If you want to terminate the node process after completing its task, set this to true.\n   *\n   * @default false\n   */\n  killAfterCompleted?: boolean;\n  /**\n   * A function to be executed in each worker process when the worker process is shutting down.\n   */\n  stop?: () => Promise<void> | void;\n  /**\n   * The timeout duration for the worker function in milliseconds.\n   * If the worker function takes longer than this duration, it will be forcefully terminated.\n   *\n   * @default 3000 (3 seconds)\n   */\n  startupTimeoutMs?: number;\n};\n\ntype PrimaryThartOptions = CommonThartOptions & {\n  primary: PrimaryFunction;\n};\n\ntype WorkerThartOptions = CommonThartOptions & {\n  worker: WorkerFunction & WorkerCount;\n};\n\ntype WorkerArrayThartOptions = CommonThartOptions & {\n  worker: (WorkerFunction & Partial<WorkerCount>)[];\n};\n\ntype PrimaryAndSingleWorkerOptions = PrimaryThartOptions & WorkerThartOptions;\n\ntype PrimaryAndArrayWorkerOptions = PrimaryThartOptions &\n  WorkerArrayThartOptions;\n\ntype ThartOptions =\n  | PrimaryThartOptions\n  | WorkerThartOptions\n  | WorkerArrayThartOptions\n  | PrimaryAndSingleWorkerOptions\n  | PrimaryAndArrayWorkerOptions;\n\ninterface NormalizedThartOptions {\n  primary: PrimaryFunction | undefined;\n  worker: WorkerFunction[];\n  grace: number;\n}\n\nexport const WORKER_TYPES = {\n  child: \"childProcess\",\n  cluster: \"cluster\",\n} as const;\n\nexport type {\n  ThartOptions,\n  NormalizedThartOptions,\n  PrimaryAndArrayWorkerOptions,\n  PrimaryAndSingleWorkerOptions,\n  PrimaryFunction,\n  PrimaryThartOptions,\n  WorkerArrayThartOptions,\n  WorkerCount,\n  WorkerThartOptions,\n  WorkerFunction,\n};\n"],"mappings":";AAAA,SAA4B,YAAY;AACxC,OAAO,aAA8B;;;ACqG9B,IAAM,eAAe;AAAA,EAC1B,OAAO;AAAA,EACP,SAAS;AACX;;;ADhGA,eAAsB,aACpB,SACA,SACe;AACf,MAAI,CAAC,QAAQ,WAAW;AACtB,UAAM,IAAI,MAAM,oDAAoD;AAAA,EACtE;AACA,MAAI,QAAQ,QAAS,OAAM,QAAQ,QAAQ,MAAM;AACjD,QAAM,iBAAiC,CAAC;AACxC,UAAQ,YAAY,YAAY;AAC9B,QAAI;AACF,YAAM,0BAA0B,QAAQ,OAAO,cAAc;AAAA,IAC/D,UAAE;AACA,UAAI,QAAQ,SAAS,KAAM,OAAM,QAAQ,QAAQ,KAAK;AACtD,cAAQ,WAAW;AAAA,IACrB;AAAA,EACF,CAAC;AACD,WAAS,IAAI,GAAG,IAAI,QAAQ,OAAO,QAAQ,KAAK;AAC9C,gBAAY,GAAG,QAAQ,OAAO,CAAC,GAAG,cAAc;AAAA,EAClD;AACF;AAEO,SAAS,YACd,GACA,cACA,gBACM;AACN,MAAI,aAAa,SAAS,aAAa,OAAO;AAC5C,UAAM,eAAe,KAAK,QAAQ,KAAK,CAAC,GAAG,CAAC,GAAG;AAAA,MAC7C,KAAK;AAAA,QACH,GAAG,QAAQ;AAAA,QACX,WAAW,EAAE,SAAS;AAAA,QACtB,aAAa,aAAa;AAAA,MAC5B;AAAA,IACF,CAAC;AACD,mBAAe,KAAK,YAAY;AAAA,EAClC,WAAW,aAAa,SAAS,aAAa,SAAS;AACrD,YAAQ,KAAK;AAAA,MACX,WAAW,EAAE,SAAS;AAAA,MACtB,aAAa,aAAa;AAAA,IAC5B,CAAC;AAAA,EACH,MAAO,OAAM,IAAI,MAAM,wBAAwB,aAAa,IAAI,EAAE;AACpE;AAgBO,SAAS,0BACd,OACA,gBACe;AACf,SAAO,IAAI,QAAc,CAAC,SAAS,WAAW;AAC5C,UAAM,YAAY,KAAK,IAAI;AAC3B,UAAM,aAAa,YAAY,MAAM;AACnC,YAAM,UAAU,oBAAoB;AAIpC,YAAM,iBAAiB,QAAQ,MAAM,CAAC,MAAM,CAAC,CAAC,KAAK,EAAE,OAAO,CAAC;AAC7D,YAAM,wBAAwB,eAAe;AAAA;AAAA;AAAA;AAAA,QAI3C,CAAC,UAAU,MAAM,eAAe,QAAQ,MAAM,aAAa;AAAA,MAC7D;AAEA,UAAI,kBAAkB,uBAAuB;AAC3C,sBAAc,UAAU;AACxB,gBAAQ;AAAA,MACV;AAEA,UAAI,KAAK,IAAI,IAAI,aAAa,OAAO;AACnC,gBAAQ,MAAM,iDAAiD;AAC/D,sBAAc,UAAU;AACxB,gBAAQ,QAAQ,CAAC,WAAW,QAAQ,KAAK,CAAC;AAC1C,uBAAe,QAAQ,CAAC,OAAO,GAAG,KAAK,CAAC;AACxC,eAAO,IAAI,MAAM,gDAAgD,CAAC;AAAA,MACpE;AAAA,IACF,GAAG,GAAG;AAAA,EACR,CAAC;AACH;AAKA,SAAS,sBAA8C;AACrD,SAAO,OAAO,OAAO,QAAQ,WAAW,CAAC,CAAC;AAC5C;","names":[]}