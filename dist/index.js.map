{"version":3,"sources":["../src/index.ts","../src/thart.ts","../src/async-shutdown.ts","../src/primary.ts","../src/types.ts","../src/validators.ts","../src/worker.ts"],"sourcesContent":["export { thart, default } from \"./thart\";\n","/**\n * Giving credit where credit is due, thart was inspired by throng: https://github.com/hunterloftis/throng\n */\nimport cluster from \"node:cluster\";\nimport { ShutdownManager } from \"./async-shutdown\";\nimport { startPrimary } from \"./primary\";\nimport {\n  WORKER_TYPES,\n  type NormalizedThartOptions,\n  type PrimaryAndArrayWorkerOptions,\n  type PrimaryAndSingleWorkerOptions,\n  type PrimaryThartOptions,\n  type ThartOptions,\n  type WorkerArrayThartOptions,\n  type WorkerCount,\n  type WorkerFunction,\n  type WorkerThartOptions,\n} from \"./types\";\nimport { validateOptions } from \"./validators\";\nimport { startWorker } from \"./worker\";\n\nconst DEFAULT_GRACE = 10000;\nconst DEFAULT_WORKER_COUNT = 1;\n\nexport default thart;\n/**\n * Start your node application with a primary process only.\n * @param {PrimaryThartOptions} opts\n * @param {number} opts.grace (optional) The grace period in milliseconds to allow for the primary process to shut down before forcefully exiting. Default is 10000 (10 seconds).\n * @param {PrimaryFunction} opts.primary The primary function configuration to be executed in the primary process\n * @param {PrimaryFunction[\"start\"]} opts.primary.start The function to be executed in the primary process when the primary process starts\n * @param {PrimaryFunction[\"stop\"]} opts.primary.stop (optional) The function to be executed in the primary process when the primary process is shutting down\n * @returns {Promise<void>}\n */\nexport async function thart(opts: PrimaryThartOptions): Promise<void>;\n/**\n * Start your node application by spawning `count` workers\n * @param {WorkerThartOptions} opts\n * @param {number} opts.grace (optional) The grace period in milliseconds to allow for the primary process to shut down before forcefully exiting. Default is 10000 (10 seconds).\n * @param {WorkerFunction} opts.worker The worker function configuration to be executed in every worker process\n * @param {WorkerFunction[\"start\"]} opts.worker.start The function to be executed in each worker process\n * @param {WorkerFunction[\"type\"]} opts.worker.type The type of child process to use.\n *  - `childProcess` uses `node:child_process` `fork`\n *  - `cluster` uses `node:cluster` `fork`\n * @param {WorkerFunction[\"count\"]} opts.worker.count The number of worker processes to spawn\n * @param {WorkerFunction[\"stop\"]}  opts.worker.stop (optional) The function to be executed in the each worker process when shut down.\n *  If it is not provided, nothing is processed on process death.\n * @param {WorkerFunction[\"startupTimeoutMs\"]} opts.worker.startupTimeoutMs (optional) The time to wait for each workers start function to finish executing.\n *  - If the worker fails to start in the allotted time, the worker process is exited.\n *  - If it is not provided, there is no timeout.\n *  - In the event a stop function was provided, it is not invoked.\n * @param {WorkerFunction[\"killAfterCompleted\"]} opts.worker.killAfterCompleted (optional) When set to `true`, the process will exit after the start function is completed.\n * @returns {Promise<void>}\n */\nexport async function thart(opts: WorkerThartOptions): Promise<void>;\n/**\n * Start your node application by spawning multiple types of workers\n * @param {WorkerArrayThartOptions} opts\n * @param {number} opts.grace (optional) The grace period in milliseconds to allow for the primary process to shut down before forcefully exiting. Default is 10000 (10 seconds)\n * @param {(WorkerFunction & Partial<WorkerCount>)[]} opts.worker An array of worker configurations\n * @param {WorkerFunction[\"start\"]} opts.worker[].start The function to be executed in this worker process\n * @param {WorkerFunction[\"type\"]} opts.worker[].type The type of child process to use in this worker process\n *  - `childProcess` uses `node:child_process` `fork`\n *  - `cluster` uses `node:cluster` `fork`\n * @param {WorkerFunction[\"count\"]} [opts.worker[].count] (optional) The number of worker processes to spawn for this worker configuration. Defaults to 1 if not specified\n * @param {WorkerFunction[\"stop\"]} [opts.worker[].stop] (optional) The function to be executed in this worker process when shut down\n *  If it is not provided, nothing is processed on process death.\n * @param {WorkerFunction[\"startupTimeoutMs\"]} [opts.worker[].startupTimeoutMs] (optional) The time to wait for this worker's start function to finish executing.\n *  - If the worker fails to start in the allotted time, the worker process is exited.\n *  - If it is not provided, there is no timeout.\n *  - In the event a stop function was provided, it is not invoked.\n * @param {WorkerFunction[\"killAfterCompleted\"]} [opts.worker[].killAfterCompleted] (optional) When set to `true`, the process will exit after the start function is completed.\n * @returns {Promise<void>}\n */\nexport async function thart(opts: WorkerArrayThartOptions): Promise<void>;\n/**\n * Start your node application with both a primary process and a single type of worker processes\n * @param {PrimaryAndSingleWorkerOptions} opts\n * @param {number} [opts.grace] (optional) The grace period in milliseconds to allow for processes to shut down before forcefully exiting. Default is 10000 (10 seconds).\n * @param {PrimaryFunction} opts.primary The primary function configuration to be executed in the primary process\n * @param {PrimaryFunction[\"start\"]} opts.primary.start The function to be executed in the primary process when it starts\n * @param {PrimaryFunction[\"stop\"]} [opts.primary.stop] (optional) The function to be executed in the primary process when it's shutting down\n * @param {WorkerFunction & WorkerCount} opts.worker The worker function configuration to be executed in every worker process\n * @param {WorkerFunction[\"start\"]} opts.worker.start The function to be executed in each worker process\n * @param {WorkerFunction[\"type\"]} opts.worker.type The type of child process to use.\n *  - `childProcess` uses `node:child_process` `fork`\n *  - `cluster` uses `node:cluster` `fork`\n * @param {WorkerCount[\"count\"]} opts.worker.count The number of worker processes to spawn\n * @param {WorkerFunction[\"stop\"]} [opts.worker.stop] (optional) The function to be executed in each worker process when shutting down.\n *  If not provided, nothing is computed on process termination.\n * @param {WorkerFunction[\"startupTimeoutMs\"]} [opts.worker.startupTimeoutMs] (optional) The time in milliseconds to wait for each worker's start function to finish executing.\n *  - If the worker fails to start in the allotted time, the worker process is exited.\n *  - If not provided, there is no timeout.\n *  - In the event a stop function was provided, it is not invoked on timeout.\n * @param {WorkerFunction[\"killAfterCompleted\"]} [opts.worker.killAfterCompleted] (optional) When set to `true`, the worker process will exit after its start function is completed.\n * @returns {Promise<void>}\n */\nexport async function thart(opts: PrimaryAndSingleWorkerOptions): Promise<void>;\n/**\n * Start your node application with both a primary process and multiple types of worker processes\n * @param {PrimaryAndArrayWorkerOptions} opts\n * @param {number} [opts.grace] (optional) The grace period in milliseconds to allow for processes to shut down before forcefully exiting. Default is 10000 (10 seconds).\n * @param {PrimaryFunction} opts.primary The primary function configuration to be executed in the primary process\n * @param {PrimaryFunction[\"start\"]} opts.primary.start The function to be executed in the primary process when it starts\n * @param {PrimaryFunction[\"stop\"]} [opts.primary.stop] (optional) The function to be executed in the primary process when it's shutting down\n * @param {(WorkerFunction & Partial<WorkerCount>)[]} opts.worker An array of worker configurations\n * @param {WorkerFunction[\"start\"]} opts.worker[].start The function to be executed in the worker processes spawned from this config\n * @param {WorkerFunction[\"type\"]} opts.worker[].type The type of child process to use for this worker type.\n *  - `childProcess` uses `node:child_process` `fork`\n *  - `cluster` uses `node:cluster` `fork`\n * @param {WorkerFunction[\"count\"]} [opts.worker[].count] (optional) The number of worker processes to spawn for this worker type. Defaults to 1 if not specified.\n * @param {WorkerFunction[\"stop\"]} [opts.worker[].stop] (optional) The function to be executed in the worker processes spawned from this config when shutting down.\n *  If not provided, nothing is computed on process termination.\n * @param {WorkerFunction[\"startupTimeoutMs\"]} [opts.worker[].startupTimeoutMs] (optional) The time in milliseconds to wait for each worker's start function to finish executing.\n *  - If the worker fails to start in the allotted time, the worker process is exited.\n *  - If not provided, there is no timeout.\n *  - In the event a stop function was provided, it is not invoked on timeout.\n * @param {WorkerFunction[\"killAfterCompleted\"]} [opts.worker[].killAfterCompleted] (optional) When set to `true`, the worker process will exit after its start function is completed.\n * @returns {Promise<void>}\n */\nexport async function thart(opts: PrimaryAndArrayWorkerOptions): Promise<void>;\nexport async function thart(opts: ThartOptions): Promise<void> {\n  validateOptions(opts);\n  const normalizedOptions = normalizeOptions(opts);\n  const manager = new ShutdownManager();\n  console.log(normalizedOptions);\n\n  // this ordering is intentional -- a spawned child process will think it is the primary\n  if (process.env.WORKER_TYPE === WORKER_TYPES.child) {\n    await startWorker(normalizedOptions, manager);\n  } else if (cluster.isPrimary) {\n    await startPrimary(normalizedOptions, manager);\n  } else if (cluster.worker) {\n    await startWorker(normalizedOptions, manager);\n  }\n}\n\nfunction normalizeOptions(options: ThartOptions): NormalizedThartOptions {\n  const primary = \"primary\" in options ? options.primary : undefined;\n  const worker = normalizeWorkerOptions(options);\n  const grace = options.grace ?? DEFAULT_GRACE;\n  return { primary, worker, grace };\n}\n\nfunction normalizeWorkerOptions(options: ThartOptions): WorkerFunction[] {\n  if (!(\"worker\" in options)) return [];\n  const workers: WorkerFunction[] = [];\n  if (Array.isArray(options.worker)) {\n    for (const worker of options.worker) {\n      for (let i = 0; i < (worker.count ?? DEFAULT_WORKER_COUNT); i++) {\n        workers.push(_getWorker(worker));\n      }\n    }\n  } else {\n    for (let i = 0; i < options.worker.count; i++) {\n      workers.push(_getWorker(options.worker));\n    }\n  }\n  return workers;\n}\n\nconst _getWorker = (\n  worker: WorkerFunction & Partial<WorkerCount>,\n): WorkerFunction => ({\n  start: worker.start,\n  stop: worker.stop,\n  type: worker.type,\n  killAfterCompleted: worker.killAfterCompleted,\n  startupTimeoutMs: worker.startupTimeoutMs,\n});\n","/**\n * This internal code is just about a carbon copy of: https://www.npmjs.com/package/async-cleanup\n * The license is ISC, found at: https://github.com/trevorr/async-cleanup/blob/master/LICENSE\n * Tests not included in this repository.\n */\nexport class ShutdownManager {\n  private cleanupListeners: Set<CleanupListener> | undefined;\n\n  // Listenable signals that terminate the process by default\n  private static readonly SIGNALS: NodeJS.Signals[] = [\n    \"SIGBREAK\", // Ctrl-Break on Windows\n    \"SIGHUP\", // Parent terminal closed\n    \"SIGINT\", // Terminal interrupt, usually by Ctrl-C\n    \"SIGTERM\", // Graceful termination\n    \"SIGUSR1\", // Used by Nodemon\n    \"SIGUSR2\", // Used by Nodemon\n  ];\n\n  constructor() {\n    this.installExitListeners();\n    this.cleanupListeners = new Set();\n  }\n\n  /**\n   * Adds a listener to be executed when the process is shutting down.\n   * @param listener - The listener to be executed when the process is shutting down.\n   * @throws If a listener is added after the process has started shutting down.\n   */\n  public addListener(listener: CleanupListener): void {\n    if (this.cleanupListeners === undefined) {\n      throw new Error(\"Cannot add cleanup listeners after cleanup\");\n    }\n    this.cleanupListeners.add(listener);\n  }\n\n  public async killAfterCleanup(signal?: NodeJS.Signals): Promise<void> {\n    await this.executeCleanupListeners();\n    process.kill(process.pid, signal);\n  }\n\n  private async exitAfterCleanup(code: number): Promise<void> {\n    await this.executeCleanupListeners();\n    process.exitCode = code;\n  }\n\n  private async executeCleanupListeners(): Promise<void> {\n    if (this.cleanupListeners === undefined) return;\n    this.uninstallExitListeners();\n    const listeners = this.cleanupListeners;\n    this.cleanupListeners = undefined;\n    const promises: Promise<void>[] = [];\n    for (const listener of listeners) {\n      try {\n        const promise = listener();\n        if (promise) promises.push(promise);\n      } catch (err) {\n        console.error(`Uncaught exception during cleanup ${err}`);\n      }\n    }\n    const results = await Promise.allSettled(promises);\n    for (const result of results) {\n      if (result.status === \"rejected\") {\n        console.error(`Unhandled rejection during cleanup ${result.reason}`);\n      }\n    }\n  }\n\n  private beforeExitListener = (code: number): void => {\n    console.debug(`Exiting with code ${code} due to empty event loop`);\n    void this.exitAfterCleanup(code);\n  };\n\n  private uncaughtExceptionListener = (error: Error): void => {\n    console.error(\"Exiting with code 1 due to uncaught exception\", error, \"\\n\");\n    void this.exitAfterCleanup(1);\n  };\n\n  private signalListener = (signal: NodeJS.Signals): void => {\n    console.debug(`Exiting due to signal ${signal}`);\n    void this.killAfterCleanup(signal);\n  };\n\n  private installExitListeners(): void {\n    process.on(\"beforeExit\", this.beforeExitListener);\n    process.on(\"uncaughtException\", this.uncaughtExceptionListener);\n    ShutdownManager.SIGNALS.forEach((signal) => {\n      process.on(signal, this.signalListener);\n    });\n  }\n\n  private uninstallExitListeners(): void {\n    process.removeListener(\"beforeExit\", this.beforeExitListener);\n    process.removeListener(\"uncaughtException\", this.uncaughtExceptionListener);\n    ShutdownManager.SIGNALS.forEach((signal) => {\n      process.removeListener(signal, this.signalListener);\n    });\n  }\n}\n\ntype CleanupListener = () => void | Promise<void>;\n","import { type ChildProcess, fork } from \"node:child_process\";\nimport cluster, { type Worker } from \"node:cluster\";\nimport type { ShutdownManager } from \"./async-shutdown\";\nimport {\n  WORKER_TYPES,\n  type NormalizedThartOptions,\n  type WorkerFunction,\n} from \"./types\";\n\nexport async function startPrimary(\n  options: NormalizedThartOptions,\n  manager: ShutdownManager,\n): Promise<void> {\n  if (!cluster.isPrimary) {\n    throw new Error(\"Can not invoke `startPrimary` outside of `primary`\");\n  }\n  if (options.primary) await options.primary.start();\n  const childProcesses: ChildProcess[] = [];\n  manager.addListener(async () => {\n    try {\n      await waitForWorkersWithTimeout(options.grace, childProcesses);\n    } finally {\n      if (options.primary?.stop) await options.primary.stop();\n      process.exitCode = 0;\n    }\n  });\n  for (let i = 0; i < options.worker.length; i++) {\n    spawnWorker(i, options.worker[i], childProcesses);\n  }\n}\n\nexport function spawnWorker(\n  i: number,\n  workerConfig: WorkerFunction,\n  childProcesses: ChildProcess[],\n): void {\n  if (workerConfig.type === WORKER_TYPES.child) {\n    const childProcess = fork(process.argv[1], [], {\n      env: {\n        ...process.env,\n        WORKER_ID: i.toString(),\n        WORKER_TYPE: WORKER_TYPES.child,\n      },\n    });\n    childProcesses.push(childProcess);\n  } else if (workerConfig.type === WORKER_TYPES.cluster) {\n    cluster.fork({\n      WORKER_ID: i.toString(),\n      WORKER_TYPE: WORKER_TYPES.cluster,\n    });\n  } else throw new Error(`Invalid worker type: ${workerConfig.type}`);\n}\n\n/**\n * Waits for all workers and child processes to terminate within a specified grace period.\n *\n * This function periodically checks the status of cluster workers and child processes.\n * It resolves when all workers and child processes have terminated.\n * If the grace period expires before all workers and child processes have terminated,\n * it forcibly terminates them and rejects with an error.\n *\n * @param {number} grace - The maximum time (in milliseconds) to wait for workers and child processes to terminate.\n * @param {ChildProcess[]} childProcesses - An array of child processes to monitor.\n * @returns {Promise<void>} A promise that resolves when all workers and child processes have terminated,\n *                          or rejects if the grace period expires.\n * @throws {Error} If the grace period expires before all workers and child processes terminate.\n */\nexport function waitForWorkersWithTimeout(\n  grace: number,\n  childProcesses: ChildProcess[],\n): Promise<void> {\n  return new Promise<void>((resolve, reject) => {\n    const startTime = Date.now();\n    const intervalId = setInterval(() => {\n      const workers = getConnectedWorkers();\n      // really this triggers when the cluster workers array is empty but we keep the isDead\n      // check for the case where cluster.workers returns a dictionary containing dead workers\n      // (though I have never observed this to be the case)\n      const allWorkersDead = workers.every((w) => !!w && w.isDead());\n      const allChildProcessesDead = childProcesses.every(\n        // need the `exitCode` check to ensure we count processes that exited due to:\n        // 1) empty event loop\n        // 2) process.exit invocations\n        (child) => child.signalCode !== null || child.exitCode !== null,\n      );\n\n      if (allWorkersDead && allChildProcessesDead) {\n        clearInterval(intervalId);\n        resolve();\n      }\n\n      if (Date.now() - startTime >= grace) {\n        console.error(\"Forcibly terminating workers after grace period\");\n        clearInterval(intervalId);\n        workers.forEach((worker) => worker?.kill());\n        childProcesses.forEach((cp) => cp.kill());\n        reject(new Error(\"Forcibly terminated workers after grace period\"));\n      }\n    }, 100);\n  });\n}\n\n/**\n * @returns An array of active workers in the cluster if invoked in the primary process, else an empty array.\n */\nfunction getConnectedWorkers(): (Worker | undefined)[] {\n  return Object.values(cluster.workers ?? {});\n}\n","interface CommonThartOptions {\n  /**\n   * The grace period for shutting down worker processes in milliseconds.\n   * This determines how long to wait for workers to finish their tasks before forcefully terminating them.\n   *\n   * @default 10000 (10 seconds)\n   */\n  grace?: number;\n}\n\ntype PrimaryFunction = {\n  /**\n   * A function to be executed in the primary process (there is only one primary process).\n   */\n  start: () => Promise<void> | void;\n  /**\n   * A function to be executed in the primary process when the primary process is shutting down.\n   * This gets invoked AFTER all worker processes have been shut down.\n   */\n  stop?: () => Promise<void> | void;\n};\n\ntype WorkerCount = {\n  /**\n   * A function to be executed in each worker process when the worker process is shutting down.\n   * @param id - The id of the worker process.\n   * @returns A promise that resolves when the worker process has completed.\n   */\n  /**\n   * The number of worker processes to spawn.\n   */\n  count: number;\n};\n\ntype WorkerFunction = {\n  /**\n   * A function to be executed in each worker process (there is no limit to the number of worker processes).\n   * @param id - The id of the worker process.\n   * @returns A promise that resolves when the worker process has completed.\n   */\n  start: (id: number) => Promise<void> | void;\n  /**\n   * The type of worker process to use.\n   * \"childProcess\" will use Node.js child processes.\n   * \"cluster\" will use Node.js cluster module.\n   *\n   * You should use:\n   * - \"cluster\" allows TCP servers to be shared between workers and is thus recommended when using TCP servers.\n   * - \"childProcess\" is recommended for CPU-bound tasks / jobs that can be run independently.\n   */\n  type: \"childProcess\" | \"cluster\";\n  /**\n   * Determines whether the worker process should be terminated after completing its task.\n   * By default, when all work in the process is done, the node process that executed the worker is still kept alive.\n   * If you want to terminate the node process after completing its task, set this to true.\n   *\n   * @default false\n   */\n  killAfterCompleted?: boolean;\n  /**\n   * A function to be executed in each worker process when the worker process is shutting down.\n   */\n  stop?: () => Promise<void> | void;\n  /**\n   * The timeout duration for the worker function in milliseconds.\n   * If the worker function takes longer than this duration, it will be forcefully terminated.\n   *\n   * @default 3000 (3 seconds)\n   */\n  startupTimeoutMs?: number;\n};\n\ntype PrimaryThartOptions = CommonThartOptions & {\n  primary: PrimaryFunction;\n};\n\ntype WorkerThartOptions = CommonThartOptions & {\n  worker: WorkerFunction & WorkerCount;\n};\n\ntype WorkerArrayThartOptions = CommonThartOptions & {\n  worker: (WorkerFunction & Partial<WorkerCount>)[];\n};\n\ntype PrimaryAndSingleWorkerOptions = PrimaryThartOptions & WorkerThartOptions;\n\ntype PrimaryAndArrayWorkerOptions = PrimaryThartOptions &\n  WorkerArrayThartOptions;\n\ntype ThartOptions =\n  | PrimaryThartOptions\n  | WorkerThartOptions\n  | WorkerArrayThartOptions\n  | PrimaryAndSingleWorkerOptions\n  | PrimaryAndArrayWorkerOptions;\n\ninterface NormalizedThartOptions {\n  primary: PrimaryFunction | undefined;\n  worker: WorkerFunction[];\n  grace: number;\n}\n\nexport const WORKER_TYPES = {\n  child: \"childProcess\",\n  cluster: \"cluster\",\n} as const;\n\nexport type {\n  ThartOptions,\n  NormalizedThartOptions,\n  PrimaryAndArrayWorkerOptions,\n  PrimaryAndSingleWorkerOptions,\n  PrimaryFunction,\n  PrimaryThartOptions,\n  WorkerArrayThartOptions,\n  WorkerCount,\n  WorkerThartOptions,\n  WorkerFunction,\n};\n","import type {\n  PrimaryFunction,\n  ThartOptions,\n  WorkerCount,\n  WorkerFunction,\n} from \"./types\";\n\nexport const validateOptions = (opts: ThartOptions) => {\n  if (typeof opts !== \"object\" || opts === null) {\n    throw new TypeError(\"Options must be an optiona\");\n  }\n\n  // assert one of \"primary\" or \"worker\" is present in the options\n  if (!(\"primary\" in opts) && !(\"worker\" in opts)) {\n    throw new TypeError(\"Must specify a `primary` or `worker` config\");\n  }\n\n  if (\"grace\" in opts) {\n    if (typeof opts.grace !== \"number\" || opts.grace < 0) {\n      throw new TypeError(\"Grace period must be a non-negative number\");\n    }\n  }\n\n  if (\"primary\" in opts) _validatePrimaryFunction(opts.primary);\n  if (\"worker\" in opts) {\n    if (Array.isArray(opts.worker)) {\n      opts.worker.forEach(_validateWorkerFunction);\n    } else {\n      _validateWorkerFunction(opts.worker);\n    }\n  }\n};\n\nconst _validatePrimaryFunction = (primary: PrimaryFunction) => {\n  if (typeof primary !== \"object\" || primary === null) {\n    throw new TypeError(\"Primary configuration must be an object\");\n  }\n\n  if (typeof primary.start !== \"function\") {\n    throw new TypeError(\"Primary start must be a provided function\");\n  }\n\n  if (\"stop\" in primary && typeof primary.stop !== \"function\") {\n    throw new TypeError(\"Primary stop, if provided, must be a function\");\n  }\n};\n\nconst _validateWorkerFunction = (\n  worker: WorkerFunction & Partial<WorkerCount>,\n) => {\n  if (typeof worker !== \"object\" || worker === null) {\n    throw new TypeError(\"Worker configuration must be an object\");\n  }\n\n  if (typeof worker.start !== \"function\") {\n    throw new TypeError(\"Worker start must be a provided function\");\n  }\n\n  if (![\"childProcess\", \"cluster\"].includes(worker.type)) {\n    throw new TypeError(\n      'Worker type must be either \"childProcess\" or \"cluster\"',\n    );\n  }\n\n  if (\"stop\" in worker && typeof worker.stop !== \"function\") {\n    throw new TypeError(\"Worker stop, if provided, must be a function\");\n  }\n\n  if (\"startupTimeoutMs\" in worker) {\n    if (\n      typeof worker.startupTimeoutMs !== \"number\" ||\n      worker.startupTimeoutMs < 0\n    ) {\n      throw new TypeError(\n        \"Worker startupTimeoutMs, if provided, must be a non-negative number\",\n      );\n    }\n  }\n\n  if (\"count\" in worker) {\n    const count = worker.count;\n    if (typeof count !== \"number\" || count < 1 || !Number.isInteger(count)) {\n      throw new TypeError(\"Worker count must be a positive integer\");\n    }\n  }\n\n  if (\n    \"killAfterCompleted\" in worker &&\n    typeof worker.killAfterCompleted !== \"boolean\"\n  ) {\n    throw new TypeError(\n      \"Worker killAfterCompleted, if provided, must be a boolean\",\n    );\n  }\n};\n","import type { ShutdownManager } from \"./async-shutdown\";\nimport type { NormalizedThartOptions } from \"./types\";\n\nconst STARTUP_TIMEOUT_MS = 5000;\n\nexport async function startWorker(\n  options: NormalizedThartOptions,\n  manager: ShutdownManager,\n): Promise<void> {\n  if (!options.worker) throw new Error(\"Missing worker function\");\n  const workerId = process.env.WORKER_ID;\n  if (!workerId) throw new Error(\"Worker ID not set\");\n  const idx = Number.parseInt(workerId);\n  const workerConfig = options.worker[idx];\n\n  // if timeout is provided, then we fail to start if we do not start within the timout window\n  if (workerConfig.startupTimeoutMs) {\n    await Promise.race([\n      new Promise((_, reject) =>\n        setTimeout(\n          () => reject(new Error(\"Worker function timed out\")),\n          workerConfig.startupTimeoutMs,\n        ),\n      ),\n      workerConfig.start(idx),\n    ]);\n  } else await workerConfig.start(idx);\n\n  // after successful initialization, register the `stop` function to the listeners for this worker\n  if (workerConfig.stop) {\n    manager.addListener(workerConfig.stop);\n  }\n  // immediately kill this worker (shutdown will run if provided)\n  if (workerConfig.killAfterCompleted) {\n    await manager.killAfterCleanup();\n  }\n}\n"],"mappings":"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","names":["import_node_cluster","cluster","cluster"]}